# Styling Components with FClasses

This document describes how to use the *AddClasses API* with functional CSS 
to style your components.

## Functional CSS

This library was developed to support a styling paradigm known as "atomic" or
"functional" CSS.  There are many excellent web resources describing the goals
and methodology of this pattern, but in its most basic form, it uses simple,
single-purpose utility classes in lieu of complex CSS selectors. Thus, for example,
instead of

```html
<div class="my-wrapper">Foo</div>
```

```css
.my-wrapper {
  background-color: blue;
  color: white;
}
```

the functional css paradigm favors

```html
<div class="bg-blue text-white">Foo</div>
```

```css
.bg-blue {
  background-color: blue;
}
.text-white {
  color: white;
}
```

Usually, a framework is used to generate the utility classes programmatically.
[Tachyons](https://tachyons.io/) and [Tailwind](https://tailwindcss.com/) are
two such frameworks. All the examples below use classes generated by Tailwind.


## FClasses API

The `FClasses` API in this library provides higher-order components which can be
used to add and remove classes from an element. They allow a single element
styled using functional utilty classes to be fully or partially restyled --
prserving some of its styles while adding or removing others. For example:

```javascript
const Div = stylable<HTMLProps<HTMLDivElement>>('div');
const Callout = addClasses('bg-blue text-white p-2 border border-yellow')(Div);
const SpecialGreenCallout = as(
  addClasses('bg-green'),
  removeClasses('bg-blue'),
)(Callout);
```

The higher order components are reusable, so for example:

```
const withRedCalloutBorder = as(
  addClasses('border-red'),
  removeClasses('border-yellow),
);
const RedBorderedCallout = withRedCalloutBorder(Callout);
const ChristmasCallout = withRedCalloutBorder(SpecialGreenCallout);
```

and they can be composed using standard functional programming techniques:

```javascript
const ChristmasCallout = asRight(
  withRedCalloutBorder,
  asSpecialGreenCallout,
  asCallout,
)('div');
```

### Some important things to remember about FClasses.

#### Always use `stylable()`

In order to use `addClasses()` or `removeClasses()`, the target component must
first be made stylable. That is:
```javascript
const BlueDiv = addClasses('bg-blue')('div');
```
will not work (and will raise a type error if using Typescript).  Instead, you must write:
```javascript
const Div = stylable<HTMLProps<HTMLDivElement>>('div');
const BlueDiv = addClasses('bg-blue')(Div);
```
or, if you prefer:
```
const BlueDiv = asRight(
  addClasses('bg-blue'),
  stylable,
)('div');
```

#### Explicitly type `stylable()` when applied to intrinsic elements.

When using typescript in the above examples, we must explicitly
specify the type of our stylable `Div` because it cannot be inferred from the
intrinsic element `'div'`.

#### Don't add classes directly.

`removeClasses()` can only remove classes which were originally added by
`addClasses()`. Thus, for example:
```javascript
const BlueDiv = ({ className, ...rest }) => <div className={`${classname} bg-blue`} {...rest} />;
const GreenDiv = removeClasses('bg-blue').addClasses('bg-green')(BlueDiv);
```
will *not* work, because the `bg-blue` class is hidden inside `BlueDiv` and not
accessible to the `removeClasses()` HOC. Instead, use:
```
const BlueDiv = addClasses('bg-blue')(Stylable('div'));
const GreenDiv = removeClasses('bg-blue').addClasses('bg-green')(BlueDiv);
```

#### Use `removeClasses()` with no arguments to remove all classes
```
const Button: FC<HTMLProps<HTMLButtonElement>> = props => <button onClick={specialClickHandler} type="button" {...props} />;
const StylableButton = stylable(Button);
const OceanButton = withClasses('text-green bg-blue italic')(StylableButton);
const DesertButton = withoutClasses().withClasses('text-yellow bg-red bold')(OceanButton);
```
This is useful when you don't have access to the original, unstyled variant of the component.
