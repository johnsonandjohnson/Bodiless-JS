# Styling Components with FClasses

This document describes how to use the _`AddClasses` API_ with functional CSS to style your
components.

## Functional CSS

This library was developed to support a styling paradigm known as "atomic" or "functional" CSS.
There are many excellent web resources describing the goals and methodology of this pattern, but in
its most basic form, it uses simple, single-purpose utility classes in lieu of complex CSS
selectors. Thus, for example, instead of—

```html
<div class="my-wrapper">Foo</div>
```

```css
.my-wrapper {
  background-color: blue;
  color: white;
}
```

—the functional CSS paradigm favors:

```html
<div class="bg-blue text-white">Foo</div>
```

```css
.bg-blue {
  background-color: blue;
}
.text-white {
  color: white;
}
```

Usually, a framework is used to generate the utility classes programmatically.
[Tachyons](https://tachyons.io/ ':target=_blank') and [Tailwind](https://tailwindcss.com/
':target=_blank') are two such frameworks. All the examples below use classes generated by Tailwind.

## FClasses API

The `FClasses` API in this library provides higher-order components which can be used to add and
remove classes from an element. They allow a single element styled using functional utility classes
to be fully or partially restyled — preserving some of its styles while adding or removing others.
For example:

```ts
const Div = stylable<HTMLProps<HTMLDivElement>>('div');
const Callout = addClasses('bg-blue text-white p-2 border border-yellow')(Div);
const SpecialGreenCallout = as(
  addClasses('bg-green'),
  removeClasses('bg-blue'),
)(Callout);
```

The higher-order components are reusable. So, for example:

```ts
const withRedCalloutBorder = as(
  addClasses('border-red'),
  removeClasses('border-yellow),
);
const RedBorderedCallout = withRedCalloutBorder(Callout);
const ChristmasCallout = withRedCalloutBorder(SpecialGreenCallout);
```

And they can be composed using standard functional programming techniques:

```ts
const ChristmasCallout = asRight(
  withRedCalloutBorder,
  asSpecialGreenCallout,
  asCallout,
)('div');
```

### Some Important Things to Remember About FClasses

#### Always use `stylable()`

In order to use `addClasses()` or `removeClasses()`, the target component must first be made
stylable. That is—

```ts
const BlueDiv = addClasses('bg-blue')('div');
```

—will not work (and will raise a type error if using TypeScript). Instead, you must write:

```ts
const Div = stylable<HTMLProps<HTMLDivElement>>('div');
const BlueDiv = addClasses('bg-blue')(Div);
```

Or, if you prefer:

```ts
const BlueDiv = asRight(
  addClasses('bg-blue'),
  stylable,
)('div');
```

#### Explicitly Type `stylable()` When Applied to Intrinsic Elements

When using TypeScript in the above examples, we must explicitly specify the type of our stylable
`Div` because it cannot be inferred from the intrinsic element `'div'`.

#### Don't Add Classes Directly

`removeClasses()` can only remove classes which were originally added by `addClasses()`. Thus, for
example—

```tsx
const BlueDiv = ({ className, ...rest }) => <div className={`${classname} bg-blue`} {...rest} />;
const GreenDiv = removeClasses('bg-blue').addClasses('bg-green')(BlueDiv);
```

—will _not_ work, because the `bg-blue` class is hidden inside `BlueDiv` and not accessible to the
`removeClasses()` HOC. Instead, use:

```ts
const BlueDiv = addClasses('bg-blue')(stylable('div'));
const GreenDiv = removeClasses('bg-blue').addClasses('bg-green')(BlueDiv);
```

#### Use `removeClasses()` With No Arguments to Remove All Classes

```tsx
const Button: FC<HTMLProps<HTMLButtonElement>> = props => <button onClick={specialClickHandler} type="button" {...props} />;
const StylableButton = stylable(Button);
const OceanButton = withClasses('text-green bg-blue italic')(StylableButton);
const DesertButton = withoutClasses().withClasses('text-yellow bg-red bold')(OceanButton);
```

This is useful when you don't have access to the original, unstyled variant of the component.
